#ifndef VECTORS_H
#define VECTORS_H

#include <stdbool.h>
#include <stdlib.h>

/**
 * @brief Encapsulates state of a dynamic, generic reference array. Functions per stored type are generated by macros called `CASK_FN_VECTOR_X`.
 * @note This vector implementation is meant to be homogeneous: it stores all items as the same type.
 * @note Caveat: This does not support storing pointer-pointer types.
 */
typedef struct cask_vector_t
{
    void **data;
    int32_t next_slot;
    int32_t capacity;
} Vector;

#define CASK_VECTOR_INIT_CAPACITY 8
#define CASK_VECTOR_MAX_CAPACITY 16384

/// @brief Type generic macro for generating an initializer function for any typed vector.
#define CASK_FN_VECTOR_INIT(type) void vector_init_ ## type(Vector *vector)\
    {\
        vector->data = calloc(CASK_VECTOR_INIT_CAPACITY, sizeof(type *));\
        if (!vector->data)\
        {\
            vector->next_slot = 0;\
            vector->capacity = -1;\
        }\
        else\
        {\
            vector->next_slot = 0;\
            vector->capacity = CASK_VECTOR_INIT_CAPACITY;\
        }\
    }\

#define CASK_FN_VECTOR_GET_PTR(type) type *vector_get_ ## type ## _ptr(const Vector *vector, int32_t index)\
    {\
        return vector->data[index];\
    }\

#define CASK_FN_VECTOR_APPEND(type) bool vector_append_ ## type(Vector *vector, type *value_ptr)\
    {\
        int32_t new_length = vector->next_slot;\
        int32_t new_capacity = 2 * vector->capacity;\
        if (new_capacity >= CASK_VECTOR_MAX_CAPACITY)\
            return false;\
        if (new_length < new_capacity)\
        {\
            vector->data[new_length] = value_ptr;\
            vector->next_slot++;\
            return true;\
        }\
        type **new_data_ptr = realloc(vector->data, sizeof(type *) * new_capacity);\
        if (new_data_ptr != NULL)\
        {\
            for (int32_t fill_index = new_length; fill_index < new_capacity; fill_index++)\
            {\
                new_data_ptr[fill_index] = NULL;\
            }\
            new_data_ptr[new_length] = value_ptr;\
            vector->data = new_data_ptr;\
            vector->capacity = new_capacity;\
            vector->next_slot++;\
        }\
        return new_data_ptr != NULL;\
    }\

/// @brief Type generic macro for generating a dispose function for any typed Vector.
#define CASK_FN_VECTOR_DISPOSE(inner_type) void vector_dispose_ ## inner_type(Vector *vector, void (*disposer_ ## inner_type)(inner_type *ptr))\
    {\
        if (!vector->data)\
            return;\
        int32_t strides = vector->next_slot;\
        inner_type **cursor = vector->data;\
        if (disposer_ ## inner_type != NULL)\
        {\
            while (strides > 0)\
            {\
                disposer_ ## inner_type(cursor);\
                cursor++;\
                strides--;\
            }\
        }\
        free(vector->data);\
        vector->data = NULL;\
    }\

#endif